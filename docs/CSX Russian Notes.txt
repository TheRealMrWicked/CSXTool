[size=75]Так-с... Недавно разобрал один формат, хотелось бы сохранить его где-нибудь в помощь потомкам :D  Спасибо WinKi за направление :)[/size]

[list]
[*]все числа в тексте - шестнадцатеричные.
[*]если я пишу "usually", это значит, что во всех/многих случаях в моём файле там было именно это значение.
[*][DW] - число типа DWord; [S] - последовательность символов (строка); [S8] - восемь символов; [US] - Unicode string (см. ниже)
[*][b]Прога для перевода[/b] будет выложена здесь: [url]http://www.solelo.com/p4s[/url][/list]


[size=200]Entis CSX:  Cotopha Image file[/size]
[i](Wanko to Lily, system\wanko.csx, 3 813 713 bytes)[/i]

[code]
Общий формат CSX-файла:
.00..40 - CSX file header
.41+    - Sections

CSX file header:
.00: [S] "Entis"#$1A#00#00
     ...
.0C: [DW] Should be zero
.10: [S] "Cotopha Image file"
     ...
.38: [DW] Contents size
     ...
[/code]
где:
[list]
[*] Should be zero - поле должно быть нулём, иначе движок выдаст сообщение о неподдерживаемом формате. Может быть, это версия, зарезирвированое поле, код расширения формата или ещё что-нибудь.
[*] Contents size - это размер всего файла, за исключением его заголовка (иными словами, это значение + 40 должно быть точно на 1 байт больше размера файла целиком).[/list]

CSX-файл состоит из секций. Их пять видов:
[list]
[*]image - собственно команды скрипта и текст. Самая большая секция.
[*]function - это таблица функций и, видимо, точек входа или ещё чего-то. Как раз то, где надо править сдвиги.
[*]global - не вдавался в детали, не влияет на возможность перевода.
[*]data - тоже самое здесь.
[*]linkinf - конкретно не знаю, что это такое, ибо в игре эта секция была пустой...[/list]

Секция имеет такой формат:
[code]
.00: [S8] ID
.08: [DW] Size
.0C: [DW] Unknown (usually 0)
[/code]
где:
[list]
[*]ID - вид секции (одно из пяти). Лишнее место заполняется пробелами (20, не нулями).
[*]Size - размер секции без учёта заголовка.[/list]

[i]Некоторые секции ещё читают дополнительный [DW] или несколько.[/i]


[size=150]Unicode string[/size]
В файле используется общий формат для всех строк, которые, кстати, все Юникод (кроме ID секций, которые ASCII). Здесь я его обозначаю [US]:
[code]
.00: [DW] Character count
.04: [S] Unicode string
[/code]
где:
[list]
[*]Character count - количество [b]символов[/b] (не байт). Чтобы получить длину строки надо помножить это на 2.
[*] Unicode string - например, 0030 BF7D...[/list]


[size=150]Linkinf section[/size]
Так как не интересовался этой секцией, могу сказать только то, что она имеет свой заголовок (в дополнение к обычному секционному):
[code]
.00: [DW] Count 1
.04: [DW] Unknonwn
.08: [DW] Count 2
.0C: [DW] Unknown
[/code]
Linkinf имеет две части, каждая из которых имеет своё количество "чего-то".


[size=150]Data section[/size]
Тоже не самая интересная секция.
[code]
Имеет свой заголовок из 4 байт
.00: [DW] Records count

Record:
.00: [US] Name 1
+00: [DW] Unknown (usually 0)
.04: [DW] Unknown (usually 80)
.0С: [US] Name 2
[/code]
Примеры (Name 1 => Name 2):
[code]
input => InputFilter
screen => Window
frameskin => ResourceManager
[/code]

[size=150]Global section[/size]
Эта секция, опять же, не представляет особого интереса, ибо не влияет на перевод. Однако вот что о ней известно:
[code]
Имеет свой заголовок из 4 байт
.00: [DW] Records count

Record:
.00: [US] Name
+00: [DW] Unknown
.04: [DW] Unknown 2
[/code]
Очень возможно, что Unknown 2 является длиной ещё одной Unicode-строки.


[size=150]Function section[/size]
А вот это самое интересное место. Здесь хранятся указатели внутрь секции image, поэтому тут нам и нужно фиксить сдвиги при изменении скрипта.

Секция состоит из двух частей. В первой хранятся просто смещения, во второй - таблица с именами и смещениями.
[i]Все адреса в этой секции относительны секции image.[/i] То есть чтобы получить абсолютный адрес, нужно прибавить к ним адрес начала image (обычно 50).

[b]Первая часть[/b]
[code]
Имеет свой заголовок из 4 байт
.00: [DW] Records count

Record:
.00: [DW] Relative offset
[/code]
где:
[list]
[*]Relative offset - относительныый адрес в секции image.[/list]

[b]Вторая часть[/b]
[code]
Имеет свой заголовок из 8 байт
.00: [DW] Unknown (usually 0)
.04: [DW] Records count

Record:
.00: Relative offset
.04: [US] Name
[/code]
где:
[list]
[*]Relative offset - относительныый адрес в секции image.[/list]


[size=150]Image section[/size]
Сообщения выводятся двумя функциями: Talk и Mess. Функция HitretNewPage ждёт реакции юзера и выводит следующее сообщение (на новый экран).

Особенностью использования Talk и Mess является то, что Talk (видимо) всегда используется для вывода сообщений, а не речи, [i]но[/i] не всегда ондо сообщение выводится только функцией Talk. Обычно сообщение делится так, что Talk выводит первые 26 символов (максимум, что умещается на экране в одной строчке), а всё остальное выводится функциями Mess (по всей видимости тоже по одной функции на одну строку).
Интересно, что любая длинная строка выводится нормально даже одной функцией. Не совсем понятно, зачем в скрипте они разбиваются таким образом.

В то же время Mess используется и для вывода речи (без начального вызова Talk). Разделить одно сообщение можно при помощи отлова HitretNewPage.


[b][u]Порядок прохождения парсера по скрипту[/u][/b] (это скрин RTF из аттача):
[img]http://pic.ipicture.ru/uploads/090530/2s0dqUPJV4.png[/img]
[attachment=0]Cotopha parser jumps.rar[/attachment]


Теперь вкратце о каждой функции.

[b]Talk[/b]
[code]
.00: [US] "Talk"
+00: [DW] Unknown (usually 01 02 00 06)
.04: [US] Message
[/code]
[b]Mess[/b]
[code]
.00: [US] "Mess"
+00: [DW] Unknown (usually 01 02 00 06)
.04: [US] Message
[/code]
[b]HitretNewPage[/b][code]
.00: [US] "HitretNewPage"
[/code]

Этого достаточно для изменения строк.


[size=150]Где и что изменять?[/size]
При изменении строки в секции image нужно изменить следующие места в CSX-файле:
[list]
[*]@38 - размер всего CSX-файлла без заголовка.
[*]"image" section: 
[*]- @08 - размер секции;
[*]- длину Unicode-строки в самом скрипте.
[*]- подправить расстояния в коротких прыжках, см. ниже.
[*]"function" section:
[*]- изменить адреса в первой части секции;
[*]- сделать тоже самое во второй части.[/list]


[size=125]Короткие прыжки[/size]

В скрипте также могут встретиться функции прыжков. Обычно там указывается относительное расстояние прыжка (то есть сколько байт пропустить). Из-за этого нужно не только изменять адреса в таблице смещений (функций, см. выше), но и отслеживать в скрипте эти прыжки и править расстояния в них при необходимости.

Например, есть функция [i]IsGameClear[/i], у которой расстояние записано здесь: [u][us] [i]IsGameClear[/i] [w] [dw] [i]distance[/i][/u] (то есть 2 неизвестных байта после имени функции, затем смещение размера DWord). Тот же синтаксис имеют аналогичные функции: [i]ChkFlagOn[/i], [i]ChkSelect[/i] и [i]OnFlag[/i].

Имена функций, как обычно, в Юникоде (для английских названий символ есть просто его код + 0x00 для 2-го байта).

[b]Ещё один момент.[/b] Функции прыжков иногда могут ссылаться на специальный код, который в этом контексте [u]тоже является прыжком[/u]. Этот код - один байт = [i]0x06[/i] и следом за ним 4 байта расстояния дял прыжка: [u][b.] [i]0x06 [/i][dw] [i]distance[/i][/u]. Так что такие "прыжки" тоже нужно отслеживать и подправлять.

Вообще, скрипты изобилуют прыжками - к примеру, в [i]Yosuga no Sora[/i] всего 4 выбора, однако в самом скрипте находится аж 22 прыжка.


[size=150]В заключение...[/size]
Радует то, что движок везде использует Unicode, поэтому проблем с любым языком (в том числе и с нашей любимой кириллицей) нет. Очень любопытен факт, что, если отключить жесткие переносы в японском стиле через небольшой хак, то движок будет сам переносить русские и английские слова и даже [url=http://www.solelo.com/p4s/img/wanko1.png]добавлять[/url] в них переносы.
Кстати, движок работает и без установленной японском локали.

На этом всё.