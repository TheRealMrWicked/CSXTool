# IMPORTS, SETUP, AND INFO# --------------------------------------------------------------------------------------import os, sys, re# this script flags all English lines in the input files for style guide violations# style guide violations are defined by the regex expressions in rules# results are outputted as a _violations.txt file# to-do# complete and sort the properNounsList# complete and sort the honorificsList# complete and sort the exclamationsList (ex: Yay, Geez, etc)# sort rules list so that we get proper priority for overlaps# consider using nltk or some other service to determine proper nouns and maybe grammarusage = 'Usage: python autoCheck.py text_file.txt'# probably not necessary, even if your system locale is not set to JP# import locale# locale.setlocale(locale.LC_ALL, 'ja')# --------------------------------------------------------------------------------------# PROGRAM DEFINITIONS# --------------------------------------------------------------------------------------# word sets to ignore for capitalization rulesproperNounsList = ['Migiwa',                   'Sora',                   'Kasugano',                   'Nogisaka',                   'Amatsume',                   'Ryouhei',                   'Hiro',                   'Kazu',                   'Haru',                   'Akira',                   'Nakazato',                   'Ryou',                   'Motoka',                   'Yahiro',                   'Nao',                   'Onii',                   'Ojou',                   'Master',                   'M\'lady',                   'Princess',                   'Onee',                   'Japanese',                   'Senpai',                   'Sensei',                   'Shinto',                   'Monday',                   'Tuesday',                   'Wednesday',                   'Thursday',                   'Friday',                   'Saturday',                   'Sunday',                   'Tokyo',                   'Takano']properNouns = '|'.join(properNounsList)honorificsList = ['sama',                  'san',                  'chan',                  'kun',                  'senpai',                  'sensei']honorificsLower = '|'.join(honorificsList)honorificsUpper = '|'.join(map(lambda x: x[0].upper() + x[1:], honorificsList))exclamationsList = []# rules is a tuple of (description of rule, regex pattern)# each element of rules is checked for each line         #|    Class     ||         Description           |      |                        Regular Expression                            |         # Capitalizationrules = [('Capitalization: Uppercase in middle of word',         '[a-z][A-Z]'                                                            ),         ('Capitalization: Uppercase in middle of sentence',     '[^\.\?\!\~"\*;\),\]]\s+(?!I[^a-zA-Z]|' + properNouns + ')[A-Z](?!.*\])'),         ('Capitalization: Lowercase after punctuation',         '(?:(?:(?<!\.\.)\.)|[\?\!])\s+[a-z]'                                    ),         ('Capitalization: Lowercase at start of line',          '^[a-z]'                                                                ),         # Honorifics         ('Honorifics: Uppercase honorific after name',          '-(' + honorificsUpper + ')\s'                                          ),         ('Honorifics: Lowercase honorific as pronoun',          '\s+(' + honorificsLower + ')\s'                                        ),         # Punctuation         ('Punctuation: Comma after ~',                          '~,'                                                                    ),         ('Punctuation: Interrobang ?!',                         '\?\!'                                                                  ),         ('Punctuation: No punctuation at end of line',          '[^\.\?\!~"\*]$'                                                        ),         ('Punctuation: Irregular number of .',                  '[^\.]\.{2}[^\.]|\.{4,}'                                                ),         ('Punctuation: Irregular number of ?',                  '[^\?]\?{2}[^\?]'                                                       ),         ('Punctuation: Irregular number of !',                  '[^\!]\!{2}[^\!]'                                                       ),         # Spacing         ('Spacing: No space after punctuation',                 '(?:(?:\] \.\.\.)|[\?\!\),;~])[^\s\.\?\!,"]'                            ),         ('Spacing: Space at start of line',                     '^\s+'                                                                  ),         ('Spacing: Too many spaces',                            ' {2,}'                                                                 ),         ('Spacing: No space after end quote',                   '[\S]"[a-zA-Z]'                                                         ),         ('Spacing: Space after open quote',                     ' " '                                                                   ),         # Encoding         ('Encoding: Non-English characters in line',            '[^\\u0000-\\u00ff\\u266a]'                                             )]# --------------------------------------------------------------------------------------# PROGRAM# --------------------------------------------------------------------------------------# print usage if we don't have enough argumentsif (len(sys.argv) < 2):    print(usage)    exit(1)for path in sys.argv[1:]:    # open and read file    try:        readFile = open(path, 'r', encoding='utf-8')    except FileNotFoundError:        print('Failed to open File ' + path)        continue    lines = []    while True:        try:            line = readFile.readline()        except UnicodeDecodeError:            print('Unicode Decode Error. Exiting')            exit(1)        else:            if line:                lines.append(line.strip())            else:                break    # flaggedLines is a list of tuples of (string of line, list of violations)    flaggedLines = []    countProcessedLines = 0    for line in lines:        # only check English lines        if not re.search('\[.*EN.*\]', line):            continue        countProcessedLines = countProcessedLines + 1        # check if it violates any of the rules. for each rule it violates, store the offending string and rule description in totalViolations        # totalViolations is a list of tuples of (string of violation, description of rule)        totalViolations = []        for rule in rules:            violations = re.findall(rule[1], line) # use regex to evaluate violations            foundStrings = [] # need this to avoid flagging duplicate violations later when processing output            for violation in violations:                if violation in foundStrings:                    continue                totalViolations.append((violation, rule[0]))                foundStrings.append(violation)        # if there are any violations, flag the line and make note of all violations        if totalViolations:            flaggedLines.append((line, totalViolations))    readFile.close()    # open the output file    outputPath = path[:path.rindex('.')] + '_violations.txt'    try:        os.remove(outputPath)    except FileNotFoundError:        pass    writeFile = open(outputPath, 'a', encoding='utf-8')    # for each flagged line, mark all violations with <<<>>> brackets, and then list out the description of all violations in order    for flaggedLine in flaggedLines:        markedLine = flaggedLine[0]        for violation in flaggedLine[1]:            markedLine = markedLine.replace(violation[0], '<<<' + violation[0] + '>>>')        writeFile.write(markedLine + '\n')        for num, violation in enumerate(flaggedLine[1]):            writeFile.write(str(num + 1) + ': ' + violation[1] + '\n')        writeFile.write('\n')    writeFile.close()    print('Flagged ' + str(len(flaggedLines)) + ' lines out of ' + str(countProcessedLines) + ' total lines in file ' + path)    # --------------------------------------------------------------------------------------